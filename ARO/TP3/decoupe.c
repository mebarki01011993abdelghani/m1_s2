#include <stdio.h>
#include <stdlib.h>
#include <glpk.h>
#include <stdbool.h>

#define STRINGLENGTH 130
#define NBROFCOEFS 400
#define TAILLECONTRAINTE 4

// A small simili-object to manage the coefficients of the main matrix

struct matrix {
    double coef[1 + NBROFCOEFS];
    int constraint_of_coef[1 + NBROFCOEFS];
    int variable_of_coef[1 + NBROFCOEFS];
    int next_coef;
};

struct matrix *new_matrix() {
    struct matrix *mat = malloc(sizeof (struct matrix));
    mat->next_coef = 1;
    return mat;
}

void matrix_add_coef(struct matrix *mat,
        int constraint,
        int variable, double value) {
    int i = mat->next_coef;
    mat->coef[i] = value;
    mat->constraint_of_coef[i] = constraint;
    mat->variable_of_coef[i] = variable;
    mat->next_coef = i + 1;
}

void matrix_load_coefficients(struct matrix *mat, glp_prob *lp) {
    glp_load_matrix(lp,
            mat->next_coef - 1,
            mat->constraint_of_coef,
            mat->variable_of_coef,
            mat->coef);
}

void matrix_free(struct matrix * mat) {
    free(mat);
}
// end of simili-object
// datas. Usually, datas should be read from a file or generated by a program.
// You should not have to store all the coefficients in a 2-dim matrix
// (as below), but instead immediately use [matrix_add_coef] each time you read
// a parameter from a file or when you generate it.
// max 0.6 x1 + 0.5 x2
// s.t. x1 + 2 x2 <= 1
// s.t. 3 x1 + x2 <= 2

double matrix_coef[TAILLECONTRAINTE][TAILLECONTRAINTE] = {
    {2, 0, 0, 0},
    {0, 2, 0, 0},
    {0, 0, 3, 0},
    {0, 0, 0, 7}
};

double *constr;
const double demand[TAILLECONTRAINTE] = {97, 610, 395, 211};
const double objective_coef[TAILLECONTRAINTE] = {1, 1, 1, 1};
const double width[TAILLECONTRAINTE] = {45, 36, 31, 14};


const int nbr_constraints = 4;
int nbr_variables = 4;

char * get_variable_name(int variable) {
    static char variable_name[STRINGLENGTH];
    sprintf(variable_name, "x_%d", variable);
    return variable_name;
}

void add_variable(glp_prob *lp, int variable, double coef_in_objective, bool integer) {
    char *variable_name = get_variable_name(variable);
    glp_set_col_name(lp, variable, variable_name);
    
    if(integer == true){
    	glp_set_col_kind(lp,variable,GLP_IV);
    }
    
    glp_set_col_bnds(lp, variable, GLP_LO, 0.0, 0.0); // 0 <= x
    glp_set_obj_coef(lp, variable, coef_in_objective);
}

void add_all_variables(glp_prob *lp,bool integer) {
    glp_add_cols(lp, nbr_variables);
    for (int variable = 1; variable <= nbr_variables; variable++)
        add_variable(lp, variable, objective_coef[variable - 1],integer);
}

void add_constraint_coefficients(struct matrix *mat, int constraint) {
    for (int variable = 1; variable <= nbr_variables; variable++)
        matrix_add_coef(mat,
            constraint,
            variable,
            matrix_coef[constraint - 1][variable - 1]);
}

void add_constraint(glp_prob *lp,
        struct matrix *mat,
        int constraint,
        double demand) {
    char constraint_name[STRINGLENGTH];
    sprintf(constraint_name, "contrainte %d", constraint);
    glp_set_row_name(lp, constraint, constraint_name);
    glp_set_row_bnds(lp, constraint, GLP_FX, demand, demand);
    add_constraint_coefficients(mat, constraint);
}

void add_all_constraints(glp_prob *lp, struct matrix *mat) {
    glp_add_rows(lp, nbr_constraints);
    for (int constraint = 1; constraint <= nbr_constraints; constraint++)
        add_constraint(lp, mat, constraint, constr[constraint - 1]);
}

void show_variable_value(int variable, double variable_value) {
    char *variable_name = get_variable_name(variable);
    printf("%s = %lf\n", variable_name, variable_value);
}

void get_solution(glp_prob *lp, double *solution) {
    for (int variable = 1; variable <= nbr_variables; variable++) {
        solution[variable] = glp_get_col_prim(lp, variable);
    }
    //use glp_mip_col_val in mixed integer programming
}

void show_solution(glp_prob *lp) {
    double optimum = glp_get_obj_val(lp);
    double solution[1 + nbr_variables];
    get_solution(lp, solution);
    printf("Best solution objective value z = %lf\n", optimum);
    for (int variable = 1; variable <= nbr_variables; variable++) {
        show_variable_value(variable, solution[variable]);
    }
}

void set_variables_and_constraints(glp_prob *lp, bool integer) {
    struct matrix *mat = new_matrix();
    add_all_variables(lp,integer);
    add_all_constraints(lp, mat);
    matrix_load_coefficients(mat, lp);
    matrix_free(mat);
}

glp_prob * create_linear_program(char *nom, bool integer) {
    glp_prob *lp = glp_create_prob();
    glp_set_prob_name(lp, nom);
    glp_set_obj_dir(lp, GLP_MAX);
    set_variables_and_constraints(lp,integer);
    return lp;
}

void solve_problem(glp_prob *lp) {
    glp_simplex(lp, NULL);
}

void solve_mixed_integer_problem(glp_prob *lp) {
    glp_iocp param;
    glp_init_iocp(&param);
    param.presolve = GLP_ON;
    param.msg_lev = GLP_MSG_ALL; // choose among GLP_MSG_(OFF|ERR|ON|ALL)
    glp_intopt(lp, &param);
}

double ** get_solution_dual(glp_prob *lp, double *solution) {
    double ** sac = calloc(TAILLECONTRAINTE, sizeof (double));
	
    for (int contrainte = 1; contrainte <= nbr_constraints; contrainte++) {
        solution[contrainte] = glp_get_row_dual(lp, contrainte);
        show_variable_value(contrainte, solution[contrainte]);
    }

    for (int i = 0; i <= nbr_constraints; i++) {
    	sac[i] = calloc(TAILLECONTRAINTE,sizeof (double));
    	 for (int a = 0; a <= nbr_constraints; a++) {
        	if(i==a){
        		sac[i][a] = solution[i];
        	}else{
        	    sac[i][a] = 0;
        	}
        }
    }
    return sac;

}


void creerSac(glp_prob *lp) {
    double solution[1 + nbr_constraints];
    // on récupère le dual
    double** sac = get_solution_dual(lp, solution);
    //création du problème du sac
    constr = width;
    double ** saveMatrix= calloc(TAILLECONTRAINTE, sizeof (double));
    for (int i = 0; i <= TAILLECONTRAINTE; i++) {
        	saveMatrix[i] = calloc(TAILLECONTRAINTE,sizeof (double));
    	 for (int a = 0; a <=TAILLECONTRAINTE; a++) {
    	 	saveMatrix[i][a] = matrix_coef[i][a];
		matrix_coef[i][a] = sac[i][a];	
	}
    }
	glp_prob *lp_sac = create_linear_program("sacA", true);

	solve_mixed_integer_problem(lp_sac);

}

int main(void) {
constr = demand;
    glp_prob *lp = create_linear_program("probleme1", false);
    //solve_problem(lp);
    creerSac(lp);
    //show_solution(lp);
    //glp_delete_prob(lp);
    //glp_free_env();
    exit(0);
}
